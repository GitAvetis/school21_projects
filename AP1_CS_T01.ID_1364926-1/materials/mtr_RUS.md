Описание структуры программы на C# и основы синтаксиса
=
**Точка входа в программу**: До версии C# 9 точка входа была статическим методом с именем Main, который объявлялся внутри класса, обычно под названием Program, находящего внутри пространства имен. Начиная с версии C# 9, для точки входа программы используются инструкции верхнего уровня — те инструкции, которые позволяют писать код без помещения его в класса или метода. 

Пример программы, которая выводит: «Hello world».

**До версии C# 9**
```C#
using System;
namespace YourNamespace
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello world!");
        }
    }
}
```
**После выхода C# 9**
```C#
Console.WriteLine("Hello World!");
```

<b>Структура программы</b>: программа на языке C# состоит из одного или нескольких файлов. Каждый файл может содержать или не содержать пространства имен. Пространство имен может содержать типы, такие как классы, структуры, интерфейсы, перечисления и делегаты или другие пространства имен.

**Компиляция кода**: платформа .NET Framework предоставляет интерфейс выполнения компилятора ICodeCompiler. Класс CSharpCodeProvider реализует этот интерфейс и предоставляет доступ к экземплярам генератора кода C# и компилятора кода. Например, создать экземпляр CSharpCodeProvider и использовать его для получения ссылки на ICodeCompiler интерфейс.

Получив ссылку на ICodeCompiler интерфейс, можно использовать ее для компиляции исходного кода. Параметры передаются компилятору с помощью CompilerParameters класса. 

Используется CompilerParameters объект, чтобы сообщить компилятору, что необходимо создать исполняемый файл (в отличие от БИБЛИОТЕКи DLL) и вывести результируемую сборку на диск. CompileAssemblyFromSource Вызов — это место, где компилируется сборка. Этот метод принимает объект параметров и исходный код, который является строкой. После компиляции кода можно проверить наличие ошибок компиляции. Для этого надо использовать возвращаемое значение из CompileAssemblyFromSource, которое является CompilerResults объектом.

**Управляющие структуры языка**:

**Следование** — алгоритмическая конструкция, отображающая естественный последовательный порядок действий. Алгоритмы, использующие только следование, называют **линейными программами**.

```C#
int x = 17;
int y = 5;
int z = x * y;
```
**Ветвление** — алгоритмическая конструкция, в которой в зависимости от результата проверки условия (ответ «да» или «нет») предусматривается выбор одного из двух вариантов дальнейших дейтсвий (ветвей). Алгоритмы, в основе которых лежит ветвление, называют **разветвляющимися**.

```C#
int year = 1918;
if (year < 2023)
    Console.WriteLine("Прошлое");
elif (year = 2023)
    Console.WriteLine("Настоящее");
else
    Console.WriteLine("Будущее");
```
**Повторение** — алгоритмическая конструкция, представляющая собой последовательность действий, выполняемых многократно. Алгоритмы, содержащие повторение, называют **циклическими** (или циклами).

```C#
int i = 2;
while (i < 13)
{
    Console.WriteLine(i * 3);
    i++;
}
```
**Составные типы данных**: структура и объединение

**Структура(struct)** — объединение элементов под одним названием. Занимает место равное сумме размеров всех входящих в нее элементов. Переменная структуры хранит в себе все значения для каждого из элементов. Поля структуры хранятся в стеке.

Операции со структурами:

* Операция членства <имя структуры>.<член структуры>;
* Операция косвенного членства <указатель на структуру> -> <член структуры>
* Операция взятия адреса &;
* Операция sizeof;
* Операция присваивания =.

**Объединение(union)** — тип, позволяющий хранить данные разных типов в одном и том же месте памяти (но не одновременно). Это способ интерпретировать по-разному одни и те же данные. Объединение занимает память, равную наибольшему из ее элементов. Переменная объединения может хранить в себе значение только одного из элементов, поэтому изменяя значение одного из элементов, предыдущее значение удаляется.

Допустимы те же операции, что и со структурами.

**Console класс**

Предоставляет стандартные потоки для консольных приложений: входной, выходной и поток сообщений об ошибках.

При запуске консольного приложения операционная система автоматически связывает с консолью три потока ввода-вывода: стандартный входной поток, стандартный поток вывода и стандартный поток вывода ошибок. Приложение может считывать входные данные пользователя из стандартного входного потока; запись обычных данных в стандартный выходной поток; и записывают данные об ошибках в стандартный поток вывода ошибок. Эти потоки представляются приложению в виде свойств Console.In, Console.Out и Console.Error.

**Виды памяти**

**Статическая** — выделение памяти до начала исполнения программы. Такая память доступна на протяжении всего времени выполнения программы.

**Автоматическая(«размещение на стеке»)** — автоматически выделяет аргументы и локальные переменные функции, а также прочую метаинформацию при вызове функции и освобождает память при выходе из неё.

Стек работает по принципу LIFO («последним пришёл — первым ушёл»).

Автоматическая память работает именно на основе стека, чтобы вызванная из любой части программы функция не затёрла уже используемую автоматическую память, а добавила свои данные в конец стека. При завершении этой функции её данные будут удалены с конца стека.

**Динамическая** — выделение памяти из ОС по требованию приложения.

Автоматическая и статическая память выделяются единоразово перед запуском программы. При их нехватке используется динамическая память.

Приложение при необходимости может запросить у ОС дополнительную память через аллокатор или напрямую через системный вызов. 

После выделения памяти в распоряжение программы поступает указатель на начало выделенной памяти, который, в свою очередь, тоже должен где-то храниться: в статической, автоматической или также в динамической памяти. Для возвращения памяти обратно в аллокатор необходим только сам указатель.

**Сборщик мусора**

Механизм оптимизации сборщика мусора определяет наилучшее время для выполнения сбора, основываясь на произведенных выделениях памяти. Когда сборщик мусора выполняет очистку, он освобождает память, выделенную для объектов, которые больше не используются приложением. Он определяет, какие объекты больше не используются, анализируя корни приложения. Корни приложения содержат статические поля, локальные переменные в стеке потока, регистры процессора, дескрипторы сборки мусора и очередь завершения. Каждый корень либо ссылается на объект, находящийся в управляемой куче, либо имеет значение NULL. Сборщик мусора может запросить остальную часть среды выполнения для этих корней. Сборщик мусора использует этот список для создания графа, содержащего все объекты, доступные из корней.

Объекты, которых нет в графе, недоступны из корней приложения. Сборщик мусора считает недостижимые объекты мусором и освобождает выделенную для них память. В процессе очистки сборщик мусора проверяет управляемую кучу, отыскивая блоки адресного пространства, занятые недостижимыми объектами. При обнаружении недостижимого объекта он использует функцию копирования памяти для уплотнения достижимых объектов в памяти, освобождая блоки адресного пространства, выделенные под недостижимые объекты. После уплотнения памяти, занимаемой достижимыми объектами, сборщик мусора вносит необходимые поправки в указатель, чтобы корни приложения указывали на новые расположения объектов. Он также устанавливает указатель управляемой кучи в положение после последнего достижимого объекта.

Память уплотняется, только если при очистке обнаруживается значительное число недостижимых объектов. Если все объекты в управляемой куче сохраняют коллекцию, сжатие памяти не требуется.

**Универсальные шаблоны**

Универсальные шаблоны позволяют точно настроить метод, класс, структуру или интерфейс в соответствии с типом обрабатываемых данных.

Универсальными шаблонами являются классы, структуры, интерфейсы и методы, которые имеют прототипы (параметры типов) для одного или нескольких типов, которые они хранят или используют.

При создании экземпляра универсального класса необходимо указать фактические типы для замены параметров типа. При этом создается новый универсальный класс, называемый сконструированным универсальным классом, с выбранными типами, заменяющими все параметры типа. Результатом является типобезопасный класс.

**Определение простого универсального класса:**

```C#
public class Generic<T>
{
    public T Field;
}
```
