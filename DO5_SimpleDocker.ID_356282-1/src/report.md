
1. [Готовый докер](#part-1-готовый-докер) \
2. [Операции с контейнером](#part-2-операции-с-контейнером) \
3. [Мини веб-сервер](#part-3-мини-веб-сервер) \
4. [Свой докер](#part-4-свой-докер) \
5. [Dockle](#part-5-dockle) \
6. [Базовый Docker Compose](#part-6-базовый-docker-compose)

## Part 1. Готовый докер

##### Возьмём официальный докер-образ с **nginx** и выкачаем его при помощи `docker pull`.
Для этого приложения Docker должно быть запущено, после чего выполним команду `docker pull nginx`:

   ![image1](/src/images/image1.png)

##### Проверим наличие докер-образа через `docker images`.

   ![image2](/src/images/image2.png)

##### Запустим докер-образ через `docker run -d [image_id|repository]` и сразу проверим, что образ запустился через `docker ps`.

   ![image3](/src/images/image3.png)

Я показал оба варианта формирования команды, которые создали нам 2 независимых контейнера с одним и тем же образом, что избыточно, так что удалим один из них с помощью команды `docker rm [имя/id контейнера]` предварительно остановив его командой `docker stop [имя/id контейнера]`.

   ![image4](/src/images/image4.png)

##### Посмотрим информацию о контейнере через `docker inspect [container_id|container_name]`.
##### По выводу команды определим и поместим в отчёт размер контейнера, список замапленных портов и ip контейнера:
т.к. необходимо узнать размер контейнера, то нам нужно будет добавить дополнительный флаг: `docker inspect great_joliot --size`, после чего получаем:

   - размер контейнера:       
        "SizeRw": 81920 ≈ 80 КБ( writable слой (изменения))
        "SizeRootFs": 173387776 ≈ 165 МБ(общий размер (базовый образ + изменения))
   - список замапленных портов:
        Ports: "80/tcp": null (значение null означает, что порты НЕ замаплены)
        Nginx слушает порт 80 внутри контейнера. Доступ к веб-серверу возможен только изнутри контейнерной сети. Для внешнего доступа нужно использовать -p 8080:80
   - ip контейнера: 
        "IPAddress": "172.17.0.3"

##### Остановим докер контейнер через `docker stop [container_id|container_name]` и проверим, что контейнер остановился через `docker ps`.

   ![image5](/src/images/image5.png)

##### Запусти докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду *run*.
Для этого нужно прописать команду  `docker run -d -p 80:80 -p 443:443 nginx`. 

   ![image6](/src/images/image6.png)

Разберём её подробнее:
- *docker run* - запуск контейнера
- *-d*(detached) - запуск в фоновом режиме
- *-p* 80:80 - маппинг порта 80 контейнера на порт 80 хоста
- *-p* 443:443 - маппинг порта 443 контейнера на порт 443 хоста
- *nginx* - образ для запуска (можно заменить на любой другой)

##### Проверим, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.
   ![image7](/src/images/image7.png)

##### Перезапустим докер контейнер через `docker restart [container_id|container_name]` и убедимся, что контейнер запустился.

   ![image8](/src/images/image8.png)

## Part 2. Операции с контейнером

Докер-образ и контейнер готовы. Теперь можно покопаться в конфигурации **nginx** и отобразить статус страницы.

##### Прочитаем конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*.
`docker exec` — это команда Docker для выполнения команд внутри уже запущенного контейнера.
Синтаксис вызова команды:  docker exec [ОПЦИИ] <container_id|container_name> <команда>
В нашем случае прописываем *docker exec amazing_carson cat /etc/nginx/nginx.conf*

   ![image9](/src/images/image9.png)

##### Создадим на локальной машине файл *nginx.conf*.
Я создал отдельный коталог для второго задания и командой `touch nginx.conf` добавил туда новый файл.
##### Настроем в нем по пути */status* отдачу страницы статуса сервера **nginx**.
Для настройки конфиг файла на локальной машине я полностью скопировал содержимое файла из контейнера и добавил в него несколько дополнительных строк, закоментировав лишь строку *include /etc/nginx/conf.d/*.conf;* во избежание конфликта портов.

   ![image10](/src/images/image10.png)

/status — это виртуальный путь в URL, который активирует встроенный модуль статистики nginx, а не обращается к реальному файлу. При обращении пользователя по адресу http://your-server/status, Nginx перехватывает запрос к пути /status если в конфиг файле stub_status включен в режиме on, и возвращает статистику в текстовом формате.

##### Скопируем созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp`.
 *docker cp nginx.conf amazing_carson:/etc/nginx/nginx.conf*

   ![image11](/src/images/image11.png)


Убедимся, что файл скопировался корректно и в нём нет ошибок:   ![image12](/src/images/image12.png)

##### Теперь мы можем перезапустить **nginx** внутри докер-образа через команду *exec* и проверить, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
Для перезапуска прописываем команду `docker exec amazing_carson nginx -s reload`, проверить же можем с мощью команды  `curl`(Отправка HTTP-запросов и получение ответов от веб-серверов):

   ![image13](/src/images/image13.png)

Либо просто открыть в браузере адрес http://localhost:80/status:

   ![image14](/src/images/image14.png)

##### Теперь экспортируем контейнер в файл *container.tar* через команду *export* после чего остановим контейнер.

   ![image15](/src/images/image15.png)

##### Удалим образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры.
Для удаления лучше использовать id образа, так как это надёжнее, узнать его можно командой `docker images`.
Теперь, зная id образа, попробуем удалить его при помощи команды `docker rmi 3b7732505933`. Команда вызовет конфликт, так как докер видит, что образ задействован в остановленном контейнере и запросит форсировать команду добавив флаг `-f`. Финальная команда будет выглядить так: ` docker rmi -f 3b7732505933`.

   ![image16](/src/images/image16.png)


##### Удалим остановленный контейнер, после чего импортируем его обратно через команду *import*.
   docker rm  amazing_carson - для удаления контейнера

   ![image17](/src/images/image17.png)

   docker import --change 'CMD ["nginx", "-g", "daemon off;"]' container.tar restored-nginx:latest - для импорта из архива. Разберём эту команду поподробнее:
   --change 'CMD ["nginx", "-g", "daemon off;"]'
   --change - флаг для изменения конфигурации образа
   CMD - инструкция Dockerfile, которая определяет команду по умолчанию(Без этого контейнер запускается и сразу завершается, т.к. не знает что выполнять)
   ["nginx", "-g", "daemon off;"] - массив команд, где 
      "nginx" - запускает nginx
      "-g" - флаг для глобальной конфигурации
      "daemon off;" - заставляет nginx работать в foreground (обязательно для Docker)

   ![image18](/src/images/image18.png)

##### Теперь запустим импортированный контейнер и проверим, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
   Командой  `docker run -d -p 80:80 restored-nginx`(-d для запуска в фоновом режиме, без захвата терминала) запустим контейнер, можем убедиться, что всё в порядке при момощи `docker ps`, после чего обратимся к адресу *localhost:80/status*.
   
   ![image19](/src/images/image19.png)

## Part 3. Мини веб-сервер

##### Напиши мини-сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello, World!`.
Для выполнения поставленной задачи я создал файл с расширением `.c` назвав его *MyServer*.
Содержание файла:

   ![image20](/src/images/image20.png)

Сервер реализован на Cи и использует FastCGI для связи с Nginx. При получении запроса программа формирует HTML-страницу с приветствием.

##### Запусти написанный мини-сервер через *spawn-fcgi* на порту 8080.
Для этого мы должны сначала скомпилировать файл `MyServer.c`, а затем прописать команду `spawn-fcgi -p 8080 -n ./`. Я запустил сервер в фонвом режиме добавив флаг `&`. После запуска в таком режиме мы так же получим номер фоновой задачи в текущей сессии терминала в квадратных скобках и уникальный идентификатор процесса (PID) в системе, которми можем воспользоваться, чтобы работу сервера остановить.

   ![image21](/src/images/image21.png)

##### Напиши свой *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*.
Для выполнения задания нам необходимо настроить прослушивание на порт 81, а так же указать адрес написанного нами сервера с указанием его формата. Содержание *nginx.conf* файла:

   ![image22](/src/images/image22.png)

##### Запусти локально **nginx** с написанной конфигурацией.
Для этого воспользуемся командой `nginx -c $(pwd)/nginx.conf`.

   ![image23](/src/images/image23.png)

##### Проверь, что в браузере по *localhost:81* отдается написанная тобой страничка.

   ![image24](/src/images/image24.png)

Чтобы остановить наш сервер, необходимо завершить два процесса:

- FastCGI-сервер - завершается командой `kill %1` (по номеру фоновой задачи) или `kill 17730` (по PID). После этого появляется сообщение о завершении процесса:
*[1] + 17730 done spawn-fcgi -p 8080 -n ./MyServer*

- Nginx прокси-сервер - останавливается командой `nginx -s stop`

##### Положим файл *nginx.conf* по пути *./nginx/nginx.conf* (это понадобится позже).

## Part 4. Свой докер

Теперь всё готово. Можно приступать к написанию докер-образа для созданного сервера.

**== Задание ==**

*При написании докер-образа избегай множественных вызовов команд RUN*

#### Напиши свой докер-образ, который:
##### 1) собирает исходники мини сервера на FastCgi из [Части 3](#part-3-мини-веб-сервер);
##### 2) запускает его на 8080 порту;
##### 3) копирует внутрь образа написанный *./nginx/nginx.conf*;
##### 4) запускает **nginx**.
_**nginx** можно установить внутрь докера самостоятельно, а можно воспользоваться готовым образом с **nginx**'ом, как базовым._
Для начала скопируем необходимые файлы из предыдущих заданий. Я взял готовый образ. Т.к. в [третьей части](#part-3-мини-веб-сервер) я запускал  *nginx* на локальной машине, конфиг файл, который я для этого использовал, не подойдёт для работы в контейнере на базе *nginx*, поэтому я взял конфиг файл из [второй части](#part-2-операции-с-контейнером) и заменил в нём часть когда, связанную с настройками сервера, взяв их из третьего пункта:

   ![image25](/src/images/image25.png)

Теперь можем создать сам `Dockerfile`. Выглядит он следующим образом: 

   ![image27](/src/images/image27.png)

- Устанавливаем зависимости для компиляции 
- Создаём рабочую директорию
- Копируем и компилируем сервер 
- Копируем наш конфиг nginx
- Копируем и скрипт запуска `start.sh`: ![image26](/src/images/image26.png)

##### Собери написанный докер-образ через `docker build` при этом указав имя и тег.
##### Проверь через `docker images`, что все собралось корректно.
`docker build -t my-server:part4` - команда для сборки образа.

   ![image28](/src/images/image28.png)
`docker images` - покажет все имеющиеся образы, как видим, после выполнения сборки в списке появился и наш новый образ. 
##### Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а (см. [Часть 2](#part-2-операции-с-контейнером)).
Для этого прописываем `docker run -d -p 80:81 my-server:part4`, чтобы проверить, что образ запустился, так же прописываем `docker ps`.

   ![image29](/src/images/image29.png)

##### Проверь, что по localhost:80 доступна страничка написанного мини сервера.

   ![image30](/src/images/image30.png)

##### Допиши в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.
Добавим в наш конфиг этот кусок:

   ![image31](/src/images/image31.png)

##### Пересобери докер-образ.
*Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий*.
Для этого я:
- удалил старый образ и контейнер:
   ![image32](/src/images/image32.png)
- сделал билд заново:
   ![image33](/src/images/image33.png)
   
##### Проверь, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**
Как видим - всё согласно заданию:

   ![image34](/src/images/image34.png)

## Part 5. **Dockle**

После написания образа никогда не будет лишним проверить его на безопасность.
##### Просканируй образ из предыдущего задания через `dockle [image_id|repository]`.

   ![image35](/src/images/image35.png)

Анализ выявил несколько проблем безопасности:

- CIS-DI-0001: Контейнер запускается от root пользователя
- CIS-DI-0006: Отсутствует HEALTHCHECK инструкция
- CIS-DI-0008: Наличие опасных setuid/setgid файлов
- CIS-DI-0010: Учетные данные в переменных окружения
- CIS-DI-0005: Content Trust не активирован

##### Исправь образ так, чтобы при проверке через **dockle** не было ошибок и предупреждений.

Исправленный вариант `Dockerfile` выглядит следующим образом:

   ![image37](/src/images/image37.png)

Комментариями я пометил участки, в которых произвёл изменения, и в связи с чем они требовались.
- CIS-DI-0001: Добавлен non-root пользователь appuser
- CIS-DI-0006: Включен HEALTHCHECK для мониторинга здоровья
- CIS-DI-0008: Удалены опасные setuid/setgid файлы
- Улучшена безопасность через --no-install-recommends
Результаты повторной проверки:

   ![image36](/src/images/image36.png)


Как видно, все ошибки и предупреждения, кроме CIS-DI-0010 и CIS-DI-0005, исчезли. На них остановимся чуть подробнее.
1. CIS-DI-0010 (Учетные данные в переменных окружения)
Причина исключения: Ошибка возникает в базовом образе nginx:latest, а не в моих слоях
Обоснование: Переменные NGINX_GPGKEYS и KEY_SHA512 используются официальным образом nginx для проверки подлинности пакетов во время установки
Безопасность: Эти ключи являются публичными GPG-ключами nginx для верификации пакетов, не содержат приватных данных

2. CIS-DI-0005 (Content Trust for Docker)
Причина исключения: Требует глобальной настройки Docker окружения
Обоснование: Для локальной разработки и тестирования включение DOCKER_CONTENT_TRUST усложняет процесс
Компромисс: В production-окружении эта проверка должна быть включена
Поэтому мы можем просто добавить в исключение эти ошибки, модернизировав вызвов команды `dockle --accept-key NGINX_GPGKEYS --accept-key KEY_SHA512 --accept-key NGINX_GPGKEY_PATH --ignore CIS-DI-0005 my-server:part5`.

Теперь вызов нашей команды не возвращает никаких проблем:

   ![image38](/src/images/image38.png)

## Part 6. Базовый **Docker Compose**

**== Задание ==**
##### Напиши файл *docker-compose.yml*, с помощью которого:
##### 1) Подними докер-контейнер из [Части 5](#part-5-инструмент-dockle) _(он должен работать в локальной сети, т. е. не нужно использовать инструкцию **EXPOSE** и мапить порты на локальную машину)_.
##### 2) Подними докер-контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.
##### Замапь 8080 порт второго контейнера на 80 порт локальной машины.
Вот, как мой выглядит моя реализация:

   ![image39](/src/images/image39.png)

Разберём подробнее его содержимое. В сегменте `services` мы видим 2 объекта: `app`и `nginx`.
- app - созданный на основе проекта из [Части 5](#part-5-инструмент-dockle). В директиве *build* указывается путь к *Dockerfile (../part5)*. Контейнер получает имя *my_app(container_name:)* и подключается к внутренней сети `internal_net`, что позволяет другим контейнерам обращаться к нему по имени app.
-  nginx - второй контейнер, формируется на основе официального образа `image: nginx:latest`, `ports: - "80:8080"`означает, что запросы, поступающие на порт 80 хоста, перенаправляются в контейнер nginx на порт 8080 , затем монтируем локальный конфигурационный файл (см. ниже) *nginx.conf в контейнер (/etc/nginx/nginx.conf)* с правами только на чтение *(:ro)*, задаём зависимость от контейнера *app* через директиву *depends_on*, чтобы *nginx* запускался только после него, после чего подключаем nginx к той же внутренней сети internal_net, чтобы обеспечить межконтейнерное взаимодействие.
- networks - в этой секции создаётся пользовательская сеть internal_net с типом bridge.
Она объединяет оба контейнера в одну общую внутреннюю сеть, позволяя им взаимодействовать по именам сервисов (nginx обращается к app по адресу http://app:81).

Конфигурационный файл `nginx.conf`:  ![image40](/src/images/image40.png)


##### Останови все запущенные контейнеры.
##### Собери и запусти проект с помощью команд `docker-compose build` и `docker-compose up`.
##### Проверь, что в браузере по *localhost:80* отдается написанная тобой страничка, как и ранее.
Для начала проверим, что у нас не запущены лишние контейнеры, после чего соберём наш проект через `docker-compose`:

   ![image41](/src/images/image41.png)

После этого можем запустить проект командой  `docker-compose up`:

   ![image42](/src/images/image42.png)

Видим, что оба сервиса проекта начали свою работу. Проверим это, открыв в браузере уже привычные нам адреса *localhost:80* и *localhost:80/status*:

   ![image43](/src/images/image43.png)
   ![image44](/src/images/image44.png)

Всё работает согласно поставленным задачам, чтобы отключить проект мы остановим его работу сочетанием кнопок `Ctrl+C`, после чего пропишем команду  `docker-compose down` и проверим, что после этого у нас не осталось активных контейнеров:

   ![image45](/src/images/image45.png)


