Объектно-ориентированное программирование в C#
=
C# — это объектно-ориентированный язык программирования. Четыре основных принципа объектно-ориентированного программирования:
* **Абстракция**. Моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы. Подробности внутренней логики скрыты от конечного пользователя. Пользователю не нужно знать, как работают те или иные классы и методы, чтоб их использовать.
* **Инкапсуляция**. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций.
* **Наследование**. Возможность создания новых абстракций на основе существующих. Наследование делает возможным повторное использование кода — если какой-то класс уже имеет какую-то логику и функции, не нужно переписывать всё это заново для создания нового класса, можно просто включить старый класс в новый, целиком.
* **Полиморфизм**. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций. Свойство одних и тех же объектов и методов принимать разные формы.

Структура класса в C#
-
Полный список возможных элементов, которые можно объявить в классе:
* Поля,
* Константы,
* Свойства,
* Методы,
* Конструкторы,
* События,
* Методы завершения,
* Индексаторы,
* Операторы,
* Вложенные типы.

Некоторые методы и свойства специально предназначены для того, чтобы их вызов или доступ к ним осуществлялся из клиентского кода, то есть из кода за пределами этого класса или структуры. Другие методы и свойства могут использоваться только в самом классе или структуре. Важно ограничить доступность кода так, чтобы только нужные элементы клиентского кода получали к нему доступ. Уровень доступности для типов и их элементов можно задать с помощью следующих модификаторов доступа:
* public;
* protected;
* internal;
* protected internal;
* private;
* private protected.

Классы поддерживают **наследование**. Класс, производный от другого класса, называемого базовым классом, автоматически включает все открытые, защищенные и внутренние члены базового класса за исключением конструкторов и методов завершения.<br>
Классы могут быть объявлены как **абстрактные**. Это означает, что один или несколько их членов не имеют реализации. Из абстрактных классов нельзя напрямую создать экземпляры. Они выполняют роль базовых классов для других классов, которые предоставляют реализацию недостающих членов.<br>

Чем же ООП в C# отличается от других языков?
-
**Java**<br>
Важное отличие между C# и Java состоит в том, что C# поддерживает перегрузку операторов, тогда как Java не поддерживает перегрузку операторов.<br>
В языке C# есть свойства класса. Однако в Java нет свойств класса.<br>

**Python**<br>
C# позволяет пользователям использовать указатели в небезопасном режиме, поскольку иногда указатели могут представлять угрозу безопасности. С другой стороны, Python вообще не позволяет использовать указатели. Вместо этого аналогичные результаты можно было бы получить, передавая объекты в функции по ссылке, как в Java.<br>

**Kotlin**<br>
В C# доступна удобная абстракция вместо методов get/set, то есть свойства. При этом традиционные поля остаются доступны.<br>
В Kotlin полей нет вообще, по умолчанию доступны только свойства. При этом, в отличие от C#, public — это область видимости по умолчанию, поэтому соответствующее ключевое слово рекомендуется опускать. Для различия свойствами, с set и без, используются все те же ключевые var/val.

Параллельное программирование в C#
=
Параллельное программирование опирается на принцип декомпозиции. Это процесс разбиения программы, алгоритма или набора данных на разделы, которые могут быть обработаны независимо.<br>
Существует два типа декомпозиции, оба из которых могут быть использованы в одном алгоритме. Это декомпозиция данных и декомпозиция задач.<br>
**Декомпозиция данных** обычно применяется для больших задач обработки данных. Это процесс разбиения большого количества данных на несколько более мелких групп. <br>
**Декомпозиция задач**, как правило, более сложна, чем декомпозиция данных, и ее труднее достичь. В данном случае происходит разбиение алгоритмов на более мелкие задачи, которые могут выполняться параллельно.<br>

Проблемы, возникающие при разработке параллельного кода
-
**Синхронизация**: необходимо гарантировать, чтобы результат задачи не использовался до тех пор, пока он не будет завершен. Также нужно предотвращать вмешательство параллельных задач друг в друга.<br>

**Состояние гонки** возникает, когда параллельные задачи зависят от общих данных. Один процесс может выполнять операции с использованием общих данных, которые временно оставляют значение в несогласованном состоянии. Если другой процесс использует несогласованные данные, может произойти непредсказуемое поведение. Хуже того, ошибки могут возникать лишь изредка и их трудно предсказать или воссоздать.

**Решение проблем**<br>
Чтобы избежать проблем с синхронизацией, необходимо использовать **блокировку**. Блокировка может быть запрошена одной задачей, чтобы предотвратить ввод раздела кода или доступ к общей переменной состояния другой задачей. Это метод, который может быть использован для синхронизации потоков и предотвращения условий гонки. Когда процесс запрашивает блокировку, которая уже была предоставлена другому потоку, первый процесс прекращает выполнение и ожидает освобождения блокировки. Говорят, что остановленный поток был заблокирован. Обычно заблокированный поток в конечном итоге получает блокировку и продолжает работать в обычном режиме. Однако при чрезмерной блокировке некоторые процессоры могут простаивать, так как им не хватает работы. Это влияет на производительность. 

Платформа .NET предоставляет несколько типов для параллельного программирования, включая набор классов параллельных коллекций, упрощенные примитивы синхронизации и типы отложенной инициализации. Эти типы можно использовать с любым кодом многопоточного приложения, включая библиотеку параллельных задач (TLP) и PLINQ.<br>

**Библиотека параллельных задач** (TPL) представляет собой набор открытых типов и API-интерфейсов в пространствах имен System.Threading и System.Threading.Tasks. Цель TPL — повышение производительности труда разработчиков за счет упрощения процедуры добавления параллелизма в приложения. TPL динамически масштабирует степень параллелизма для наиболее эффективного использования всех доступных процессоров. Кроме того, в библиотеке параллельных задач осуществляется секционирование работы, планирование потоков в пуле ThreadPool, поддержка отмены, управление состоянием и выполняются другие низкоуровневые задачи. Используя библиотеку параллельных задач, можно повысить производительность кода, сосредоточившись на работе, для которой предназначена программа.
